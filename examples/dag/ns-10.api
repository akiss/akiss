/*  Needham-Schroeder symmetric key
  A -> S : A, B, Na
  S -> A : {B, Na, Kab, {A, Kab}Kbs }Kas
  A -> B : { A, Kab }Kbs
  B -> A : { Req, Nb }Kab
  A -> B : { Rep, Nb }Kab


 Secrecy of the key Kab (from the point of view of B)
 encoded as a combination of key usability and “which key-concealing”
 B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants


 Scenario:
 one honest session between a, b, and s
 one instance of A played by a with c (dishonest)
 one intance of B played by b with c (dishonest)
 two additional instances of S played with a/c and c/b
 one honest session between b, a, and s
*/

/*
free a.
free b.
free c.
free kcs.

free m1.
free m2.
free req.
free rep.

free c1.
free c2.
free c3.
free c4.
free c5.
free c6.
free c7.
free c8.
free c9.
free c10.*/
chan c1,c2,c3,c4,c5,c6,c7,c8,c9,c10.
fun senc/2,sdec/2,aa/0,bb/0,cc/0,kcs/0,m1/0,m2/0,req/0,rep/0.
sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
 new na;
 out(ca, (a,b,na));
 in(ca,xenc);
 let (x1,x2,x3,x4) = sdec(xenc,kas) in
 if (x1,x2) = (b,na) then
 out(ca, x4);
 in(ca,xchall);
 let (xreq,xnb) = sdec(xchall,x3) in
 out(ca,senc((rep,xnb),x3)).

let S(cs,a,b,kas,kbs) =
 in(cs, y);
 let (y1,y2,y3) = y in
 if (y1,y2) = (a,b) then
 new kab;
 out(cs, senc((b,y3,kab,senc((a,kab),kbs)),kas)).


let B(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 if (zrep,znb) = (rep,nb) then 0.

let B1(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 if (zrep,znb) = (rep,nb) then out(cb,senc(m1,z3)).


let B2(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 new k;
 if (zrep,znb) = (rep,nb) then out(cb,senc(m2,k))..


let P =
 new kas; new kbs; (
   A(c1,aa,bb,kas) | S(c2,aa,bb,kas,kbs) | B1(c3,bb,aa,kbs) |
   A(c4,aa,cc,kas) | S(c5,aa,cc,kas,kcs) | S(c6,cc,bb,kcs,kbs) | B(c7,bb,cc,kbs) |
   A(c8,bb,aa,kbs) | S(c9,bb,aa,kbs,kas) | B(c10,aa,bb,kas)
 ).


let Q =
 new kas; new kbs; (
   A(c1,aa,bb,kas) | S(c2,aa,bb,kas,kbs) | B2(c3,bb,aa,kbs) |
   A(c4,aa,cc,kas) | S(c5,aa,cc,kas,kcs) | S(c6,cc,bb,kcs,kbs) | B(c7,bb,cc,kbs) |
   A(c8,bb,aa,kbs) | S(c9,bb,aa,kbs,kas) | B(c10,aa,bb,kas)
 )..


query trace_equiv (P, Q).
//query saturate P.
