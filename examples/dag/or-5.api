(*
  Otway Rees symmetric key
   A -> B : M,A,B,{Na,M,A,B}Kas
   B -> S : M,A,B,{Na,M,A,B}Kas,{Nb,M,A,B}Kbs
   S -> B : M, {Na,Kab}Kas, {Nb,Kab}Kbs
   B -> A : M,{Na,Kab}Kas
*)

//Channels :
chan ca1,cb1,cs1.
chan ca2,cb2,cs2.
chan ca3,cb3,cs3.
chan ca4,cb4,cs4.
chan ca5,cb5,cs5.
chan ca6,cb6,cs6.

//Constants:
fun aa/0,bb/0,cc/0.
fun s1/0,s2/0.
fun kcs/0.

// Encryption
fun senc/2,sdec/2.
 sdec(senc(x,y),y) -> x.

// Alice
let A(ca,a,b,kas) =
  new m ;
  new na ;
  out(ca,(m,a,b,senc((na,m,a,b),kas)));
  in(ca,x0);
  let (xmm,xsenc) = x0 in
  let (xna,xkab) = sdec(xsenc,kas) in
  if (xmm,xna) = (m,na) then
  0.


// Bob
let B(cb,b,a,kbs) =
  in(cb,yinit);
  let (ym,=a,=b,yza1) = yinit in
  new nb;
  out(cb,(ym,a,b,yza1,senc((nb,ym,a,b),kbs)));
  in(cb,y1);
  let (=ym,yza2,y2) = y1 in
  let (=nb,ykab) = sdec(y2,kbs) in
  out(cb,(ym,yza2)).


// Server (+property)
let S1a(cs,a,b,kas,kbs) =
  in(cs,z0);
  let (zm,=a,=b,zsenc1,zsenc2) = z0 in
  let (zna,=zm,=a,=b) = sdec(zsenc1,kas) in
  let (znb,=zm,=a,=b) = sdec(zsenc2,kbs) in
  out(cs,(zm,senc((zna,s1),kas),senc((znb,s1),kbs))).

let S1b(cs,a,b,kas,kbs) =
  in(cs,z0);
  let (zm,=a,=b,zsenc1,zsenc2) = z0 in
  let (zna,=zm,=a,=b) = sdec(zsenc1,kas) in
  let (znb,=zm,=a,=b) = sdec(zsenc2,kbs) in
  out(cs,(zm,senc((zna,s2),kas),senc((znb,s2),kbs))).


// Server
let S(cs,a,b,kas,kbs) =
  in(cs,z0);
  let (zm,=a,=b,zsenc1,zsenc2) = z0 in
  let (zna,=zm,=a,=b) = sdec(zsenc1,kas) in
  let (znb,=zm,=a,=b) = sdec(zsenc2,kbs) in
  new kab;
  out(cs,(zm,senc((zna,kab),kas),senc((znb,kab),kbs))).

let P =
  new kas; new kbs ;
  (
    A(ca1,aa,bb,kas) | S1a(cs1,aa,bb,kas,kbs) | B(cb1,bb,aa,kbs) |    // A -> S -> B
    A(ca2,aa,cc,kas) | S(cs2,aa,cc,kas,kcs)                       // A -> S -> C
  ).

let Q =
  new kas; new kbs ;
  (
    A(ca1,aa,bb,kas) | S1b(cs1,aa,bb,kas,kbs) | B(cb1,bb,aa,kbs) |    // A -> S -> B
    A(ca2,aa,cc,kas) | S(cs2,aa,cc,kas,kcs)                       // A -> S -> C
  )..

query trace_equiv(P,Q).
