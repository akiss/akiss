/*
Wide Mouthed Frog protocol (without timestamps)
A -> S: A, {B,Kab}Kas
S -> B: {A,Kab}Kbs


Secrecy of the key Kab (from the point of view of B)
encoded as a combination of key usability and “which key-concealing”
B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants

Scenario:
one honest session between a, b, and s
one instance of A played by a with c (dishonest)
one intance of B played by b with c (dishonest)
two additional instances of S played with a/c and c/b
one honest session between b, a, and s
*/


chan c0,c1,c2,c3,c4,c5,c6,c7,c8,c9.
fun senc/2,sdec/2,aa/0,bb/0,cc/0,m1/0,m2/0,kcs/0.
sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
  new kab;
  out(ca, (a, senc((b,kab),kas))).

let S(cs,a,b,kas,kbs) =
  in(cs, x);
  let (xa,xenc) = x in
  if xa = a then
  let (xb,xk) = sdec(xenc,kas) in
  if xb = b
  then out(cs, senc((a,xk),kbs)).


let B(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in 0.

let B1(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then out(cb,senc(m1,yk)).

let B2(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then new k; out(cb,senc(m2,k)).


let P =
  new kas; new kbs; (
    A(c0,aa,bb,kas) | S(c1,aa,bb,kas,kbs) | B1(c2,bb,aa,kbs) |
    A(c3,aa,cc,kas) | S(c4,aa,cc,kas,kcs) |
    S(c5,cc,bb,kcs,kbs) | B(c6,cc,bb,kbs) |
    A(c7,bb,aa,kbs) | S(c8,bb,aa,kbs,kas) | B(c9,aa,bb,kas)
  ).

let Q =
  new kas; new kbs; (
    A(c0,aa,bb,kas) | S(c1,aa,bb,kas,kbs) | B2(c2,bb,aa,kbs) |
    A(c3,aa,cc,kas) | S(c4,aa,cc,kas,kcs) |
    S(c5,cc,bb,kcs,kbs) | B(c6,cc,bb,kbs) |
    A(c7,bb,aa,kbs) | S(c8,bb,aa,kbs,kas) | B(c9,aa,bb,kas)
  )..

  query trace_equiv (P,Q).
