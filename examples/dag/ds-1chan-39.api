/*
  Denning Sacco symmetric key
  A -> S : A, B
  S -> A : {B, Kab, {Kab,A}Kbs }Kas
  A -> B : {Kab, A }Kbs


 Secrecy of the key Kab (from the point of view of A)
 encoded as a combination of key usability and “which key-concealing”
 A -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants


 Scenario:
 one honest session between a, b, and s
 one instance of A played by a with c (dishonest)
 one intance of B played by b with c (dishonest)
 two additional instances of S played with a/c and c/b
 one honest session between b, a, and s
*/

/*
free a.
free b.
free c.
free kcs.

free m1.
free m2.

free c.
free c.
free c.
free c.
free c.
free c.
free c.
free c.
free c.
free c.*/
free a1,b1,c0,kcs,m1,m2.
fun senc/2,sdec/2.
chan c.

sdec(senc(x,y),y) -> x.

let A1(ca,a,b,kas) =
 out(ca, (a,b));
 in(ca,xenc);
 let (x1,x2,x3) = sdec(xenc,kas) in
 if x1 =b then
 out(ca, x3);
 out(ca,senc(m1,x2)).

let A2(ca,a,b,kas) =
 out(ca, (a,b));
 in(ca,xenc);
 let (x1,x2,x3) = sdec(xenc,kas) in
 if x1 =b then
 out(ca, x3);
 new k;
 out(ca,senc(m2,k)).

let A(ca,a,b,kas) =
 out(ca, (a,b));
 in(ca,xenc);
 let (x1,x2,x3) = sdec(xenc,kas) in
 if x1 =b then
 out(ca, x3).

let S(cs,a,b,kas,kbs) =
 in(cs, y);
 let (y1,y2) = y in
 if (y1,y2) = (a,b) then
 new kab;
 out(cs, senc((b,kab,senc((kab,a),kbs)),kas)).


let B(cb,b,a,kbs) =
 in(cb,z);
 let (z1,z2) = sdec(z,kbs) in
 if z2 = a then 0.

let P =
 new kas; new kbs;
 ( A1(c,a1,b1,kas) | S(c,a1,b1,kas,kbs) | B(c,b1,a1,kbs)
  | A(c,a1,c0,kas) | S(c,a1,c0,kas,kcs)
  | S(c,c0,b1,kcs,kbs) |  B(c,b1,c0,kbs)
  | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
  | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
  | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)
  | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
  | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
  | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)

     | A(c,a1,c0,kas) | S(c,a1,c0,kas,kcs)
  | S(c,c0,b1,kcs,kbs) |  B(c,b1,c0,kbs)
  | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
  | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
  | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)
  | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
  | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
  | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)

).


let Q =
 new kas; new kbs;
 ( A2(c,a1,b1,kas) | S(c,a1,b1,kas,kbs) | B(c,b1,a1,kbs)
 | A(c,a1,c0,kas) | S(c,a1,c0,kas,kcs)
 | S(c,c0,b1,kcs,kbs) |  B(c,b1,c0,kbs)
 | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
 | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
 | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)
  | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
  | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
  | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)

    | A(c,a1,c0,kas) | S(c,a1,c0,kas,kcs)
 | S(c,c0,b1,kcs,kbs) |  B(c,b1,c0,kbs)
 | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
 | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
 | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)
  | A(c,b1,a1,kbs) | S(c,b1,a1,kbs,kas) | B(c,a1,b1,kas)
  | A(c,b1,c0,kcs) | S(c,b1,c0,kbs,kcs)
  | S(c,c0,a1,kcs,kas) | B(c,a1,c0,kas)

).


query trace_equiv (P,Q).
