(* public communication channel *)
chan c.
chan chMS, chSN.


(* constant values *)
free SyncFail, MacFail,reject, Sqn.

(* UMTS AKA protocol specific mac and key generation functions *)
fun f0/2.
fun f1/2.
fun f2/2.
fun f3/2.
fun f4/2.
fun f5/2.



(* public key generation function *)
fun pub/1.

(* public key encryption function *)
fun aenc/3.
fun adec/2.
adec(k, aenc(pub(k), r, m)) -> m.

let AKA_MS(ch,k,osqn,pbN,imsi) =
  new r_ms;
  in(ch, x);
  let (xrand, xautn) = x in
  let (msg, xmac) = xautn in
  let ak = f5(k, xrand) in
  let xsqn = ak + msg in
  (
    let mac = f1(k, (xrand, xsqn)) in
    if (xmac, xsqn) = (mac, osqn)
    then (
      let res = f2(k, xrand) in
      let ck = f3(k, xrand) in
      let ik = f4(k, xrand) in
      out(ch, res);
      in(ch, xmsg)
    ) else
      new rand;
      new r;
      out(ch, SyncFail)
  )
  else
    new rand;
    new r;
    out(ch, MacFail).


let AKA_SN(ch,osqn,k)=
    new rand;
    new s;
    new r;
    let mac = f1(k, (rand, osqn)) in
    let res = f2(k, rand) in
    let ck = f3(k, rand) in
    let ik = f4(k, rand) in
    let ak = f5(k, rand) in
    let autn = (ak + osqn, mac) in
    let av = (rand, res, ck, ik, ak) in
    out(ch, (rand, autn));
    in(ch, xres);
    if xres = res
    then out(ch, (ck + s))
    else out(ch, reject).



let single_session(ch1,ch2,pbN,k,imsi) =
  new osqn;
  ( AKA_MS(ch1,k,osqn,pbN,imsi) | AKA_SN(ch2,osqn,k)).

let Process1 =
  new pvN;
  let pbN = pub(pvN) in
  out(c,pbN);
  !^20  (new k; new imsi; single_session(chMS,chSN,pbN,k,imsi)).

let Process2 =
  new pvN;
  let pbN = pub(pvN) in
  out(c,pbN);
  ( new k; new imsi; !^20 single_session(chMS,chSN,pbN,k,imsi) ).

query trace_equiv(Process1,Process2).
