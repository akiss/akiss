// Direct Authentication Protocol as decribed in Gong's paper (1993)
// Protecting Poorly Chosen Secrets from Guessing Attacks (page 13)

// A -> B: ra, {pubA}pw
// B -> A: {B, A, nb1, nb2, cb, {ra}pw}pubA
// A -> B: {nb1, k + nb2}pw
// B -> A: {f1(ra),rb}k
// A -> B: {f2(rb)}k

// pw is a poorly choosen secret between A and B


fun  senc/2, sdec/2, f1/1, f2/1, aenc/2, adec/2, pk/1.
free A,B.
chan C,CA, CB, CA2, CB2,G.

reduc adec(aenc(X,pk(Y)),Y) -> X.
reduc senc(sdec(X,Y),Y) -> X.
reduc sdec(senc(X,Y),Y) -> X.


// Role A 

let Alice(pw,skA) =  
  new ra;
  out(CA,(ra,senc(pk(skA),pw)));
  in(CA, X0);
  let (=B,=A,nb1,nb2,cb,=senc(ra,pw)) = adec(X0,skA) in 
  new k;
  out(CA, senc((nb1,k + nb2),pw));
  in(CA, X1);
  let (=f1(ra),rb) = sdec(X1,k) in
  out(CA, senc(f2(rb),k)).


// Role B

let Bob(pw) = 
  in(CB,Y);
  let (ra,Y2) = Y in 
  let pubA = sdec(Y2,pw) in
  new cb;
  new nb1;
  new nb2;
  out(CB,aenc((B,A,nb1,nb2,cb,senc(ra,pw)),pubA));
  in(CB,Y3);
  let (=nb1,knb2) = sdec(Y3,pw) in
  let k = knb2 + nb2 in 
  new rb;
  out(CB, senc((f1(ra),rb), k));
  in(CB,Y4);
  if Y4 = senc(f2(rb),k) then 0.



let P(pw) = new skA;(  Alice(pw,skA) |  Bob(pw)) .

let Pw = new pw; (P(pw) | phase 2; out(G,pw)).

let Pfresh = new pw;new n;(P(pw) | phase 2; out(G,n)).

query trace_incl(Pw,Pfresh).
