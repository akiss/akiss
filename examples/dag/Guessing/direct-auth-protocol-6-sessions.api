// Direct Authentication Protocol as decribed in Gong's paper (1993)
// Protecting Poorly Chosen Secrets from Guessing Attacks (page 13)

// A -> B: ra, {pubA}pw
// B -> A: {B, A, nb1, nb2, cb, {ra}pw}pubA
// A -> B: {nb1, k + nb2}pw
// B -> A: {f1(ra),rb}k
// A -> B: {f2(rb)}k

// pw is a poorly choosen secret between A and B


fun  fst/1,snd/1,pair/2,senc/2, sdec/2, f1/1, f2/1, aenc/2, adec/2, pk/1.
free A,B.
chan C,CA, CB, CA2, CB2,G.

reduc adec(aenc(X,pk(Y)),Y) -> X.
reduc senc(sdec(X,Y),Y) -> X.
reduc sdec(senc(X,Y),Y) -> X.
reduc fst(pair(X,Y)) -> X.
reduc snd(pair(X,Y)) -> Y.
reduc pair(fst(X),snd(Y)) -> pair(X,Y).


// Role A 

let Alice(pw,skA) =  
  new ra;
  out(CA,(ra,senc(pk(skA),pw)));
  in(CA, X0);
  let (=B,=A,nb1,nb2,cb,=senc(ra,pw)) = adec(X0,skA) in 
  new k;
  out(CA, senc(pair(nb1,k + nb2),pw));
  in(CA, X1);
  if f1(ra) = fst(X1) then
  let rb = snd(sdec(X1,k)) in
  out(CA, senc(f2(rb),k)).


// Role B

let Bob(pw) = 
  in(CB,Y);
  let (ra,Y2) = Y in 
  let pubA = sdec(Y2,pw) in
  new cb;
  new nb1;
  new nb2;
  out(CB,aenc((B,A,nb1,nb2,cb,senc(ra,pw)),pubA));
  in(CB,Y3);
  if nb1 = fst(sdec(Y3,pw)) then
  let k = snd(sdec(Y3,pw)) + nb2 in 
  new rb;
  out(CB, senc(pair(f1(ra),rb), k));
  in(CB,Y4);
  if Y4 = senc(f2(rb),k) then 0.



let P(pw) = new skA;( !^3 Alice(pw,skA) | !^3 Bob(pw)) .

let Pw = new pw; (P(pw) | phase 2; out(G,pw)).

let Pfresh = new pw;new n;(P(pw) | phase 2; out(G,n)).

query trace_incl(Pw,Pfresh).
