/*
A, B, S :  principal
Na, Nb : fresh numbers
Kas, Kbs, Kab :   key

1.   A -> B : A, Na
2.   B -> S : {1, A, Na, Nb}Kbs
3.   S -> A : {2, B, Kab, Na, Nb}Kas
4.   S -> B : {3, A, Kab}Kbs
5.   A -> B : {4, A, B, S, Nb}Kab
*/
/*
//Channels :

free ch1.
free ch2.
free ch3.
free ch4.
free ch5.
free ch6.
free ch7.
free ch8.
free ch9.
free ch10.

//Public data :
free a.
free b.
free c.
free s.
free m1.
free m2.
free ok.

//Tags :
free c1.
free c2.
free c3.
free c4.

//Dishonnest key:
free kcs.
*/
chan ch1,ch2,ch3,ch4,ch5,ch6,ch7,ch8,ch9,ch10.
fun senc/2,sdec/2,aa/0,bb/0,cc/0,s/0,m1/0,m2/0,ok/0,c1/0,c2/0,c3/0,c4/0,kcs/0.
sdec(senc(x,y),y) -> x.

// A role :

let A(ca,a,b,kas) =
  new na;
  out(ca,(a,na));
  in(ca,x0);
  let (xc2,xb,xkab,xna,xnb) = sdec(x0,kas) in
  if (xc2,xb,xna) = (c2,b,na) then
  out(ca,senc((c4,a,b,s,xnb),xkab)).

// Role B :

let B(cb,b,a,kbs) =
  in(cb,y0);
  let (ya,yna) = y0 in
  if ya = a then
  new nb;
  out(cb,senc((c1,a,yna,nb),kbs));
  in(cb,y1);
  let (y2,y3) = y1 in
  let (yc3,yaa,ykab) = sdec(y2,kbs) in
  if (yc3,yaa) = (c3,a) then
  let (yc4,yaaa,ybb,yss,ynb) = sdec(y3,ykab) in
  if (yc4,yaaa,ybb,yss,ynb) = (c4,a,b,s,nb) then
  out(cb,ok).

let BP(cb,b,a,kbs) =
  in(cb,y0);
  let (ya,yna) = y0 in
  if ya = a then
  new nb;
  out(cb,senc((c1,a,yna,nb),kbs));
  in(cb,y1);
  let (y2,y3) = y1 in
  let (yc3,yaa,ykab) = sdec(y2,kbs) in
  if (yc3,yaa) = (c3,a) then
  let (yc4,yaaa,ybb,yss,ynb) = sdec(y3,ykab) in
  if (yc4,yaaa,ybb,yss,ynb) = (c4,a,b,s,nb) then
  out(cb,senc(m1,ykab)).

let BQ(cb,b,a,kbs) =
  in(cb,y0);
  let (ya,yna) = y0 in
  if ya = a then
  new nb;
  out(cb,senc((c1,a,yna,nb),kbs));
  in(cb,y1);
  let (y2,y3) = y1 in
  let (yc3,yaa,ykab) = sdec(y2,kbs) in
  if (yc3,yaa) = (c3,a) then
  let (yc4,yaaa,ybb,yss,ynb) = sdec(y3,ykab) in
  if (yc4,yaaa,ybb,yss,ynb) = (c4,a,b,s,nb) then
  new k;
  out(cb,senc(m2,k)).


// S Role :

let S(cs,a,b,kas,kbs) =
  in(cs,z0);
  let (zc1,za,zna,znb) = sdec(z0,kbs) in
  if (zc1,za) = (c1,a) then
  new kab;
  out(cs,(senc((c2,b,kab,zna,znb),kas),senc((c3,a,kab),kbs)) ).


// Protocols :

let P =
  new kas; new kbs; (
    A(ch1,aa,bb,kas) | S(ch2,aa,bb,kas,kbs) | BP(ch3,bb,aa,kbs) |
    A(ch4,aa,cc,kas) | S(ch5,aa,cc,kas,kcs) | S(ch6,cc,bb,kcs,kbs) | B(ch7,bb,cc,kbs) |
    A(ch8,bb,aa,kbs) | S(ch9,bb,aa,kbs,kas) | B(ch10,aa,bb,kas)
  ).

let Q =
  new kas; new kbs; (
    A(ch1,aa,bb,kas) | S(ch2,aa,bb,kas,kbs) | BQ(ch3,bb,aa,kbs) |
    A(ch4,aa,cc,kas) | S(ch5,aa,cc,kas,kcs) | S(ch6,cc,bb,kcs,kbs) | B(ch7,bb,cc,kbs) |
    A(ch8,bb,aa,kbs) | S(ch9,bb,aa,kbs,kas) | B(ch10,aa,bb,kas)
  ).

query trace_equiv (P,Q).
