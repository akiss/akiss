(* Wide Mouthed Frog protocol (without timestamps)
# A -> S: A, {B,Kab}Kas
# S -> B: {A,Kab}Kbs
*)

free a,b,c.

free s1,s2, kcs.


chan ca1,cs1,cb1.

fun senc/2.
fun sdec/2.
sdec(senc(x,y),y) -> x.


let A(ch,ida,idb,kas,s) =
  out(ch, (ida, senc((idb,s),kas))).


let S(ch,ida,idb,kas,kbs) =
  in(ch, x);
  let (=ida,xenc) = x in
  let (=idb,xk) = sdec(xenc,kas) in
  out(ch, senc((ida,xk),kbs)).

let B(ch,idb,ida,kbs) =
  in(ch,y);
  let (ya,yk) = sdec(y,kbs) in 0.


let Scenario(s) =
  new kas; new kbs;
 ( A(ca1,a,b,kas,s) | S(cs1,a,b,kas,kbs) | B(cb1,b,a,kbs) ).

let P = Scenario(s1).

let Q = Scenario(s2).

query trace_equiv(P,Q).
