(* Wide Mouthed Frog protocol (without timestamps)
# A -> S: A, {B,Kab}Kas
# S -> B: {A,Kab}Kbs
*)

free a,b,c.

free s1,s2, kcs.


chan ca,cb,cs.

fun senc/2.
fun sdec/2.
sdec(senc(x,y),y) -> x.


let A(ch,ida,idb,kas,s) =
  out(ch, (ida, senc((idb,s),kas))).


let S(ch,ida,idb,kas,kbs) =
  in(ch, x);
  let (=ida,xenc) = x in
  let (=idb,xk) = sdec(xenc,kas) in
  out(ch, senc((ida,xk),kbs)).

let B(ch,idb,ida,kbs) =
  in(ch,y);
  let (ya,yk) = sdec(y,kbs) in 0.


let Scenario(s) =
  new kas; new kbs;
 (
   A(ca,a,b,kas,s) | B(cb,b,a,kbs) | S(cs,a,b,kas,kbs) |

   ( !^2 new kab; A(ca,a,b,kas,kab) ) | ( !^2 B(cb,b,a,kbs) ) | ( !^2 S(cs,a,b,kas,kbs) ) |
   ( !^2 new kab; A(cb,b,a,kbs,kab) ) | ( !^2 B(ca,a,b,kas) ) | ( !^2 S(cs,b,a,kbs,kas) ) |

   ( !^2 new kab; A(ca,a,c,kas,kab) ) | ( !^2 S(cs,a,c,kas,kcs) ) |
   ( !^2 new kab; A(cb,b,c,kbs,kab) ) | ( !^2 S(cs,b,c,kbs,kcs) ) |

   ( !^2 B(cb,b,c,kbs) ) | ( !^2 S(cs,c,b,kcs,kbs) ) |
   ( !^2 B(ca,a,c,kas) ) | ( !^2 S(cs,c,a,kcs,kas) )

).


let P = Scenario(s1).

let Q = Scenario(s2).

query trace_equiv(P,Q).
